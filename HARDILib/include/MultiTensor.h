#ifndef MULTITENSOR_H
#define MULTITENSOR_H
#include <stdio.h>
#include "GDTI.h"
#include "Tensor.h"
#include <vector>
#include <set>
#include "hungarian.h"
class MultiTensor{
	protected:
		int numCompartments;
		int *compartmentSegmentation;
		double *volumeFractions;
		double *rotationMatrices;
		double *diffusivities;//[mm^2/s];
		double *prodDiffusivities;
		double *alpha;//in case of have been generated by a DBF
		int nAlpha;
		double *directions;
		int *groups;
		void initDefault(void);
		void initNull(void);
		bool selected;
		
	public:
		MultiTensor();
		MultiTensor(int nCompartments);
		~MultiTensor();
		void copyFrom(MultiTensor &M);
		void copyComponentFrom(MultiTensor &M, int from, int to);
		void createFromAlphaProfile(int _nAlpha, double *_alpha, double *_directions, double *_diffProfile);
		//--------member accessors-------
		int getNumCompartments(void)const;
		void getPDD(int k, double *pdd)const;
		void getPDDs(double *pdd)const;
		double getVolumeFraction(int k)const;
		double *getVolumeFractions(void);
		double getMaxVolumeFraction(void);
		int getMaxVolumeFractionIndex(void);
		int *getCompartmentSegmentation(void);
		int getCompartmentSegmentation(int k);
		double *getRotationMatrices(void);
		double *getDiffusivities(void);
		double *getDiffusivities(int k);
		double *getProdDiffusivities(void);
		double *getAlpha(void);
		double getMaxAlpha(void);
		int getMaxAlphaIndex(void);
		double *getDirections(void);
		int *getGroups(void);
		void setGroups(std::vector<std::set<int> > &vsGroups);
		void setGroups(std::vector<std::set<std::pair<double, int> > > &vsGroups);
		void setGroups(int *_groups, int n);
		int getNumAlpha(void);
		void setAlpha(double *_alpha, int _nAlpha);
		void setSortedCoefficientsAndDirections(double *_alpha, double *_directions, int _nAlpha);
		void setDirections(double *_directions, int _nDirections);

		void setVolumeFractions(double *vf);
		void setVolumeFraction(int k, double vf);
		void setCompartmentSegmentation(int k, int lab);
		void setCompartmentSegmentation(int *seg);
		void setRotationMatrix(int k, double *R);
		void setRotationMatrix(int k, double azimuth, double zenith);
		void setRotationMatrixFromPDD(int k, double *pdd);
		void setDiffusivities(int k, double lambdaMin, double lambdaMid, double lambdaMax);
		void setDiffusivities(int k, double *_lambda);
		void setDiffusivities(double *_lambda);

		void fitMultiTensor(double S0, double *S, double *gradients, int numGradients, 
								 double b, double *DBFDirections, int numDBFDirections);
		const double getMinAngleDegrees(void)const;
		const double getMaxIntraAngleDegrees(void)const;
		void setSelected(bool b);
		bool isSelected(void);

		//-------------------------------
		void allocate(int nCompartments);
		void dellocate(void);
		void dropSmallPeaks(double prop);
		int numLeavesContentionTree(double b);
		void setTensorAt(int k, MultiTensor &T, int sel=0);
		void setTensorAt(int k, Tensor &T);
		void recomputeBestR2Tensor(GDTI &H);
		
		
		void computeFractionalAnisotropy(double *FA);
		void computeODF(double *directions, int nDirections, double *ODF)const;
		double computeSignal(double *bCoord);
		void addNoise(double *S, int len, double sigma, double *Sn);
		void acquireWithScheme(double *b, double *gradList, int nDir, double sigma, double *S);
		void acquireWithScheme(double b, double *gradList, int nDir, double sigma, double *S);
		void rotationFromAngles(double azimuth, double zenith, double *M);
		void split(int k, GDTI &H, double *DBFDirections, double *DBFunctions, double transDiffusion, double longDiffusion);
		void split(GDTI &H, double *DBFDirections, double *DBFunctions);
		void split_angle_threshold(double angle, GDTI &H, double *DBFDirections, double *DBFunctions, double transDiffusion, double longDiffusion);
		void group_exponential(int k, GDTI &H, double *DBFDirections, double *DBFunctions, double transDiffusion, double longDiffusion);
		void fitDBFToSignal(double *S, GDTI &H, double *DBFDirections, int numDBFDirections, double b, double longDiffusion, double transDiffusion, bool iterateDiffProp=false);
		void fitDBFToSignal_baseline(double *S, GDTI &H, double *DBFDirections, double *&Phi, int numDBFDirections, double longDiffusion, double transDiffusion, std::vector<std::set<int> > &neighborhoods, double BPT);
		void loadFromTxt(FILE *F);
		void saveToTxt(FILE *F);
		void loadFromBinary(FILE *F);
		void saveToBinary(FILE *F);
		
		

		void drawEllipsoid(int k, double px, double py, double pz, double intensiry, bool clusterColors=false);
		void drawArrows(double px, double py, double pz, bool showGroupColors);
		void drawDiffusionFunction(double px, double py, double pz, int type);//0=ADF, 1=ODF
		void drawSampledFunction(double px, double py, double pz, double *samplingPoints, int n);
};
void assignTensors(double *pddsA, int n, double *pddsB, int m, double *jSegment, int *assignment, Hungarian &hungarianSolver);
double colinearityMeasure(double *dirA, double *dirB, double *displacementDir, double d0, double theta0, double dTheta0);
double parallelityMeasure(double *dirA, double *dirB, double *displacementDir, double d0, double theta0, double dTheta0);
#endif
